# .pipelines/template.yml
# Modern reusable template for Azure SQL database operations using Service Connection
parameters:
- name: tableName
  type: string
  displayName: 'Target SQL Table Name'
- name: updateType
  type: string
  displayName: 'Update Type (APPEND or REPLACE)'
  default: 'APPEND'
  values:
  - APPEND
  - REPLACE
- name: dataFilePath
  type: string
  displayName: 'Path to data file (CSV/JSON/Excel)'
- name: azureSubscription
  type: string
  displayName: 'Azure Service Connection Name'
  default: 'dbetst'
- name: sqlServerName
  type: string
  displayName: 'Azure SQL Server Name'
- name: databaseName
  type: string
  displayName: 'Database Name'

steps:
- task: AzurePowerShell@5
  displayName: 'Validate Parameters and File'
  inputs:
    azureSubscription: ${{ parameters.azureSubscription }}
    ScriptType: 'InlineScript'
    azurePowerShellVersion: 'LatestVersion'
    Inline: |
      Write-Host "=== Database Update Parameters ==="
      Write-Host "Server: ${{ parameters.sqlServerName }}"
      Write-Host "Database: ${{ parameters.databaseName }}"
      Write-Host "Table Name: ${{ parameters.tableName }}"
      Write-Host "Update Type: ${{ parameters.updateType }}"
      Write-Host "Data File Path: ${{ parameters.dataFilePath }}"
      
      # Validate update type
      $validTypes = @('APPEND', 'REPLACE')
      if ('${{ parameters.updateType }}' -notin $validTypes) {
          Write-Error "Invalid update type. Must be APPEND or REPLACE"
          exit 1
      }
      
      # Check if data file exists
      if (-not (Test-Path '${{ parameters.dataFilePath }}')) {
          Write-Error "Data file not found: ${{ parameters.dataFilePath }}"
          exit 1
      }
      
      Write-Host "Parameters validated successfully"

- task: AzurePowerShell@5
  displayName: 'Install Required Modules'
  inputs:
    azureSubscription: ${{ parameters.azureSubscription }}
    ScriptType: 'InlineScript'
    azurePowerShellVersion: 'LatestVersion'
    Inline: |
      Write-Host "Installing required PowerShell modules..."
      
      # Install modules if not present
      $modules = @('ImportExcel', 'SqlServer')
      foreach ($module in $modules) {
          if (-not (Get-Module -ListAvailable -Name $module)) {
              Write-Host "Installing $module..."
              Install-Module -Name $module -Force -AllowClobber -Scope CurrentUser
          } else {
              Write-Host "$module already installed"
          }
      }
      
      Write-Host "Modules ready"

- task: AzurePowerShell@5
  displayName: 'Process Data and Update Database'
  inputs:
    azureSubscription: ${{ parameters.azureSubscription }}
    ScriptType: 'InlineScript'
    azurePowerShellVersion: 'LatestVersion'
    Inline: |
      # Import required modules
      Import-Module ImportExcel -Force
      Import-Module SqlServer -Force
      
      $serverName = '${{ parameters.sqlServerName }}'
      $databaseName = '${{ parameters.databaseName }}'
      $tableName = '${{ parameters.tableName }}'
      $updateType = '${{ parameters.updateType }}'
      $dataFilePath = '${{ parameters.dataFilePath }}'
      
      Write-Host "=== Starting Database Update Process ==="
      Write-Host "Server: $serverName"
      Write-Host "Database: $databaseName"
      Write-Host "Table: $tableName"
      Write-Host "Update Type: $updateType"
      Write-Host "Data File: $dataFilePath"
      
      try {
          # Test connectivity first
          $serverFQDN = "$serverName.database.windows.net"
          Write-Host "Testing connectivity to: $serverFQDN"
          
          # Get access token once for all operations
          $accessToken = (Get-AzAccessToken -ResourceUrl "https://database.windows.net/").Token
          
          # Determine file type and read data
          $fileExtension = [System.IO.Path]::GetExtension($dataFilePath).ToLower()
          
          switch ($fileExtension) {
              '.csv' {
                  Write-Host "Reading CSV file..."
                  $data = Import-Csv -Path $dataFilePath
              }
              '.json' {
                  Write-Host "Reading JSON file..."
                  $jsonContent = Get-Content -Path $dataFilePath -Raw | ConvertFrom-Json
                  # Handle both array of objects and single object
                  $data = if ($jsonContent -is [array]) { $jsonContent } else { @($jsonContent) }
              }
              '.xlsx' {
                  Write-Host "Reading Excel file..."
                  $data = Import-Excel -Path $dataFilePath
              }
              default {
                  throw "Unsupported file format: $fileExtension. Supported formats: .csv, .json, .xlsx"
              }
          }
          
          if ($data.Count -eq 0) {
              Write-Warning "No data found in file: $dataFilePath"
              return
          }
          
          Write-Host "Successfully read $($data.Count) records from file"
          
          # Check if table exists and create if necessary
          Write-Host "Checking if table [$tableName] exists..."
          $tableExistsQuery = "SELECT COUNT(*) as TableCount FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = '$tableName'"
          $tableExistsResult = Invoke-Sqlcmd -ServerInstance $serverFQDN -Database $databaseName -Query $tableExistsQuery -AccessToken $accessToken
          
          if ($tableExistsResult.TableCount -eq 0) {
              Write-Host "Table [$tableName] does not exist. Creating table..."
              
              # Analyze data to determine column types
              $columns = $data[0].PSObject.Properties.Name
              $columnDefinitions = @()
              
              foreach ($column in $columns) {
                  # Sample a few records to determine best data type
                  $sampleValues = $data | Select-Object -First 10 | ForEach-Object { $_.$column } | Where-Object { $null -ne $_ -and $_ -ne '' }
                  
                  if ($sampleValues.Count -eq 0) {
                      # No data to analyze, default to NVARCHAR
                      $columnDefinitions += "[$column] NVARCHAR(255) NULL"
                      continue
                  }
                  
                  # Determine data type based on sample values
                  $isNumeric = $true
                  $isInteger = $true
                  $isDate = $true
                  $maxLength = 0
                  
                  foreach ($value in $sampleValues) {
                      $valueStr = $value.ToString()
                      $maxLength = [Math]::Max($maxLength, $valueStr.Length)
                      
                      # Check if numeric
                      if (-not ($valueStr -match '^-?\d*\.?\d+$')) {
                          $isNumeric = $false
                          $isInteger = $false
                      } elseif ($valueStr -contains '.') {
                          $isInteger = $false
                      }
                      
                      # Check if date
                      try {
                          [DateTime]::Parse($valueStr) | Out-Null
                      } catch {
                          $isDate = $false
                      }
                  }
                  
                  # Determine SQL data type
                  if ($isInteger -and $isNumeric) {
                      $columnDefinitions += "[$column] INT NULL"
                  } elseif ($isNumeric) {
                      $columnDefinitions += "[$column] DECIMAL(18,2) NULL"
                  } elseif ($isDate -and $maxLength -le 10) {
                      $columnDefinitions += "[$column] DATE NULL"
                  } elseif ($isDate) {
                      $columnDefinitions += "[$column] DATETIME2 NULL"
                  } else {
                      # String data - determine appropriate length
                      $suggestedLength = [Math]::Max(255, [Math]::Min(4000, $maxLength * 2))
                      $columnDefinitions += "[$column] NVARCHAR($suggestedLength) NULL"
                  }
              }
              
              # Create table
              $createTableSql = "CREATE TABLE [$tableName] (" + ($columnDefinitions -join ', ') + ")"
              Write-Host "Creating table with SQL: $createTableSql"
              
              try {
                  Invoke-Sqlcmd -ServerInstance $serverFQDN -Database $databaseName -Query $createTableSql -AccessToken $accessToken
                  Write-Host "Table [$tableName] created successfully"
              } catch {
                  Write-Error "Failed to create table: $($_.Exception.Message)"
                  throw
              }
          } else {
              Write-Host "Table [$tableName] already exists"
          }
          
          # Handle REPLACE operation
          if ($updateType -eq 'REPLACE') {
              Write-Host "Performing REPLACE operation - clearing existing data..."
              $deleteQuery = "DELETE FROM [$tableName]"
              Invoke-Sqlcmd -ServerInstance $serverFQDN -Database $databaseName -Query $deleteQuery -AccessToken $accessToken
              Write-Host "Existing data cleared from table: $tableName"
          }
          
          # Prepare bulk insert using Invoke-Sqlcmd
          Write-Host "Starting bulk insert operation..."
          
          # Get column names from first record
          $columns = $data[0].PSObject.Properties.Name
          $columnList = ($columns | ForEach-Object { "[$_]" }) -join ', '
          
          # Insert data in batches
          $batchSize = 100  # Smaller batches for Invoke-Sqlcmd
          $totalRecords = $data.Count
          $insertedCount = 0
          
          for ($i = 0; $i -lt $totalRecords; $i += $batchSize) {
              $batch = $data[$i..([Math]::Min($i + $batchSize - 1, $totalRecords - 1))]
              
              # Build batch insert statement
              $valuesList = @()
              foreach ($record in $batch) {
                  $values = @()
                  foreach ($column in $columns) {
                      $value = $record.$column
                      if ($null -eq $value -or $value -eq '') {
                          $values += "NULL"
                      } else {
                          # Escape single quotes and wrap in quotes
                          $escapedValue = $value.ToString() -replace "'", "''"
                          $values += "'$escapedValue'"
                      }
                  }
                  $valuesList += "(" + ($values -join ', ') + ")"
              }
              
              $insertSql = "INSERT INTO [$tableName] ($columnList) VALUES " + ($valuesList -join ', ')
              
              try {
                  Invoke-Sqlcmd -ServerInstance $serverFQDN -Database $databaseName -Query $insertSql -AccessToken $accessToken -QueryTimeout 300
                  $insertedCount += $batch.Count
                  Write-Host "Processed $insertedCount of $totalRecords records..."
              } catch {
                  Write-Error "Batch insert failed at record $insertedCount`: $($_.Exception.Message)"
                  throw
              }
          }
          
          Write-Host "=== Database Update Completed Successfully ==="
          Write-Host "Total records processed: $insertedCount"
          Write-Host "Table: $tableName"
          Write-Host "Operation: $updateType"
          
      } catch {
          Write-Error "Database update failed: $($_.Exception.Message)"
          Write-Error $_.ScriptStackTrace
          exit 1
      }

- task: AzurePowerShell@5
  displayName: 'Verify Data Load'
  inputs:
    azureSubscription: ${{ parameters.azureSubscription }}
    ScriptType: 'InlineScript'
    azurePowerShellVersion: 'LatestVersion'
    Inline: |
      try {
          Import-Module SqlServer -Force
          
          $serverName = '${{ parameters.sqlServerName }}'
          $databaseName = '${{ parameters.databaseName }}'
          $tableName = '${{ parameters.tableName }}'
          $serverFQDN = "$serverName.database.windows.net"
          
          # Get record count using Invoke-Sqlcmd
          $countQuery = "SELECT COUNT(*) as RecordCount FROM [$tableName]"
          $result = Invoke-Sqlcmd -ServerInstance $serverFQDN -Database $databaseName -Query $countQuery -AccessToken (Get-AzAccessToken -ResourceUrl "https://database.windows.net/").Token
          $recordCount = $result.RecordCount
          
          Write-Host "=== Data Load Verification ==="
          Write-Host "Server: $serverName"
          Write-Host "Database: $databaseName"
          Write-Host "Table: $tableName"
          Write-Host "Total records in table: $recordCount"
          Write-Host "Verification completed successfully"
          
      } catch {
          Write-Warning "Could not verify data load: $($_.Exception.Message)"
      }
